Given:
M = Multiplicand (from data memory)  // Assuming its at Mem[0]
R = Multiplier (from data memory)    // Assuming its at Mem[1]
A = 0
Q_minus_1 = 0
Count = 16
while Count > 0:
Q_0 = LSB of R
if Q_0 == 1 and Q_minus_1 == 0:
A = A - M
if Q_0 == 0 and Q_minus_1 == 1:
A = A + M
# Arithmetic shift right (A, R, Q_minus_1)
Q_minus_1 = LSB of R
R = R >> 1 (arithmetic shift)
LSB of A -> MSB of R
A = A >> 1 (arithmetic shift, preserve sign bit)
Count = Count - 1
# Final 32-bit result is in {A, R}
# Combine {A, R} into R2 for the result



3 Address Codes:
LD R1 0(R0)      // Loading M in R1
LD R2 1(R0)      // Loading R in R2  (Array indices are automatically multiplied by 4)
ADDI R3 R0 0     // R3 is A (now 0)
ADDI R4 R0 0     // R4 is Q_minus_1 (now 0)
ADDI R5 R0 16    // R5 is Count
LOOP: BMI R5 END
BZ R5 END
ANDI R6 R2 1     // R6 is Q_0
BZ R6 Label1     // i.e., if Q_0 == 0, then condition is false and skip A=A-M
BPL R4 Label1    // i.e., if Q_minus_1 > 0, then condition is false and skip A=A-M
SUB R3 R3 R1
Label1: BPL R6 Label2     // i.e., if Q_0 > 0, then condition is false and skip A=A+M
BZ R4 Label2    // i.e., if Q_minus_1 == 0, then condition is false and skip A=A+M
ADD R3 R3 R1
Label2: ANDI R4 R2 1
SRAI R2 R2 1
SLI R7,R3,#15        // R7 = A's sign bit in MSB position
ANDI R2 R2 0111111111111111   // To make MSB (i.e. 15th bit (0 indexed)) to 0
OR R2,R2,R7         // insert MSB(A) into R's MSB
SRAI R3 R3 1
SUBI R5 R5 1
BR LOOP
END: ADDI R10 R0 1111111111111111   // Temp reg
AND R2 R2 R10
SLI R3 R3 16
OR R2 R2 R3
ST R2 R0 0
HALT




Instructions in Binary:
11000000000100000000000000000000
11000000001000000000000000000001
10000010001100000000000000000000
10000010010000000000000000000000
10000010010100000000000000010000
10101001000001010000000000010001
10101011000001010000000000010000
10001000011000100000000000000001
10101011000001100000000000000011
10101010000001000000000000000010
00000011001100110001000000000000
10101010000001100000000000000011
10101011000001000000000000000010
00000010001100110001000000000000
10001000010000100000000000000001
10010001001000100000000000000001
10010100011100110000000000001111
10001000001000100111111111111111
00001001001000100111000000000000
10010001001100110000000000000001
10000011010101010000000000000001
10101000000000001111111111110000
10000010101000001111111111111111
00001000001000101010000000000000
10010100001100110000000000010000
00001001001000100011000000000000
11000001001000000000000000000000
01111000000000000000000000000000

